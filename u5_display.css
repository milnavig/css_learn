/* Позиционирование елементов 
https://webref.ru/css/display */
#block1 {
    width: 20px;
    height: 300px;
    border: 1px solid red;
}
#block2 {
    width: 25px;
    height: 350px;
    border: 1px solid green;
}
#block3 {
    width: 30px;
    height: 200px;
    border: 1px solid blue;
}

/* block */
/* Элемент показывается как блочный. Применение этого значения для строчных элементов, например <span>, заставляет его вести подобно блокам — происходит перенос строк в начале и в конце содержимого. */
.stroka {
    display: block;
}

/* inline */
/* Элемент отображается как строчный. Использование блочных элементов, таких, как <div> и <p>, автоматически создаёт перенос и показывает их содержимое с новой строки. Значение inline отменяет эту особенность, поэтому содержимое блочных элементов начинается с того места, где окончился предыдущий элемент. */
/* Ведет себя странно, строки не переносит, на размер блока не смотрит */
.inline {
    display: inline;
}

/* inline-block */
/* Это значение генерирует блочный элемент, который обтекается другими элементами веб-страницы подобно строчному элементу. Фактически такой элемент по своему действию похож на встраиваемые элементы (вроде <img>). При этом его внутренняя часть форматируется как блочный элемент, а сам элемент — как строчный. */
.block1 {
    width: 200px;
    height: 300px;
    border: 1px solid red;
}
.block2 {
    width: 250px;
    height: 350px;
    border: 1px solid green;
}
.block3 {
    width: 300px;
    height: 200px;
    border: 1px solid blue;
}

.inline-block {
    display: inline-block;
}

/* inline-table, table, table-caption, table-cell, table-column, table-column-group, table-footer-group, table-header-group, table-row, table-row-group не используют почти */

/* none */
/* Временно удаляет элемент из документа. Занимаемое им место не резервируется, и веб-страница формируется так, словно элемента и не было. Изменить значение и сделать вновь видимым элемент можно с помощью скриптов, обращаясь к свойствам через объектную модель. В этом случае происходит переформатирование данных на странице с учётом вновь добавленного элемента. */
.none {
    display: none;
}

/* run-in */
/* Устанавливает элемент как блочный или строчный, в зависимости от контекста. */
/* Почему-то не работает */
.run-in {
    display: run-in;
}

/* list-item */
/* Элемент выводится как блочный и добавляется маркер списка. */
.list-item {
    display: list-item;
}

/* Flexbox http://css.yoksel.ru/flexbox/ */
/* Это технология, созданная именно для раскладки элементов, в отличие от float-ов. С помощью Flexbox можно легко выравнивать элементы по горизонтали и по вертикали, менять направление и порядок отображение элементов, растягивать блоки на всю высоту родителя или прибивать их к нижнему краю. 

Для начала надо знать, что flex-элементы располагаются по осям. По умолчанию элементы располагаются по горизонтали — вдоль main axis — главной оси.

Так же следует иметь в виду, что при использовании Flexbox для внутренних блоков не работают float, clear и vertical-align, а так же свойства, задающие колонки в тексте. */
.flex-container {
    width: 600px;
    padding: 10px;
    background: gold;
    border-radius: 10px;
}
.flex-item {
    margin: 10px;
    padding: 5px;
    background: tomato;
    border-radius: 5px;
    border: 1px solid #FFF;
}

/* И теперь родительскому элементу добавляем display: flex;. Внутренние div-ы выстраиваются в ряд (вдоль главной оси) колонками одинаковой высоты, независимо от содержимого. */
#flex {
    display: flex;
}

/* Свойство display для Flexbox может принимать два значения:

flex — ведёт себя как блочный элемент. При рассчете ширины блоков приоритет у раскладки (при недостаточной ширине блоков контент может вылезать за границы). 
inline-flex — ведёт себя как инлайн-блочный. Приоритет у содержимого (контент растопыривает блоки до необходимой ширины, чтобы строчки, по возможности, поместились). */
#inline-flex {
    display: inline-flex;
}

/* Flex-direction 
Направление раскладки блоков управляется свойством flex-direction.

Возможные значения:
row — строка (значение по умолчанию);
row-reverse — строка с элементами в обратном порядке;
column — колонка;
column-reverse — колонка с элементами в обратном порядке. */
#flex-direction {
    display: flex;
    flex-direction: row-reverse;
}

/* Flex-wrap 
В одной строке может быть много блоков. Переносятся они или нет определяет свойство flex-wrap.

Возможные значения:

nowrap — блоки не переносятся (значение по умолчанию);
wrap — блоки переносятся;
wrap-reverse — блоки переносятся и располагаются в обратном порядке. */
#flex-wrap {
    display: flex;
    flex-wrap: wrap-reverse;
}

/* Order 
Для управления порядком блоков служит свойство order.

Возможные значения: числа.
Чтобы поставить блок самым первым, задайте ему order: -1: */
#order {
    display: flex;
}

#first {
    order: -1;
}

/* Justify-content */
/* Для выравнивания элементов есть несколько свойств: justify-content, align-items и align-self.

justify-content и align-items применяются к родительскому контейнеру, align-self — к дочерним.

justify-content отвечает за выравнивание по главной оси.

Возможные значения justify-content:

flex-start — элементы выравниваются от начала главной оси (значение по умолчанию);
flex-end — элементы выравниваются от конца главной оси;
center — элементы выравниваются по центру главной оси;
space-between — элементы выравниваются по главной оси, распределяя свободное место между собой;
space-around — элементы выравниваются по главной оси, распределяя свободное место вокруг себя. */
.flex-container1 {
    width: 1000px;
    padding: 10px;
    background: gold;
    border-radius: 10px;
}
#flex-end {
    display: flex;
    justify-content: flex-end;
}
#space-between {
    display: flex;
    justify-content: space-between;
}
#center {
    display: flex;
    justify-content: center;
}
#space-around {
    display: flex;
    justify-content: space-around;
}

/* Align-items */
/* align-items отвечает за выравнивание по перпендикулярной оси.

Возможные значения align-items:

flex-start — элементы выравниваются от начала перпендикулярной оси;
flex-end — элементы выравниваются от конца перпендикулярной оси;
center — элементы выравниваются по центру;
baseline — элементы выравниваются по базовой линии;
stretch — элементы растягиваются, занимая все пространство по перпендикулярной оси (значение по умолчанию). */
.flex-container2 {
    width: 1000px;
    height: 150px;
    padding: 10px;
    background: gold;
    border-radius: 10px;
}
#center1 {
    display: flex;
    align-items: center;
}

/* Align-self */
/* align-self также отвечает за выравнивание по перпендикулярной оси, но задается отдельным flex-элементам.

Возможные значения align-self:

auto — значение по умолчанию. Означает, что элемент использует align-items родительского элемента;
flex-start — элемент выравнивается от начала перпендикулярной оси;
flex-end — элемент выравнивается от конца перпендикулярной оси;
center — элемент выравнивается по центру;
baseline — элемент выравнивается по базовой линии;
stretch — элемент растягивается, занимая все пространство по высоте. */
#center-item {
    display: flex;
}
#third {
    align-self: flex-end;
}

/* Align-content */
/* Для управления выравниванием внутри многострочного flex-контейнера есть свойство align-content.

Возможные значения:

flex-start — элементы выравниваются от начала главной оси;
flex-end — элементы выравниваются от конца главной оси;
center — элементы выравниваются по центру главной оси;
space-between — элементы выравниваются по главной оси, распределяя свободное место между собой;
space-around — элементы выравниваются по главной оси, распределяя свободное место вокруг себя;
stretch — элементы растягиваются, заполняя всю высоту (значение по умолчанию). */
.flex-container3 {
    width: 500px;
    height: 300px;
    padding: 10px;
    background: gold;
    border-radius: 10px;
}
#align-content {
    display: flex;
    flex-wrap: wrap;
    align-content: flex-end;
}